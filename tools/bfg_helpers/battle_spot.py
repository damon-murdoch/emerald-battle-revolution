# Showdown Format Parser
import src.parser as parser

# Common Library
import src.common as common

# Built-in libs
import json
import os

# Headers to be added to the
# battle spot trainer object,
# instead of the nested trainer object
battle_spot_headers = [
    'tier', 'rating'
]

# Input File Folders
# .set files will be treated as individual sets
# .team files will be treated as an entire team
INPUT_FOLDER = "tools/bfg_helpers/battle_spot"

# Output Files

OUTPUT_DIR = "src/data/battle_frontier"

# Generic mons (for spare slots)
OUTPUT_MONS = os.path.join(OUTPUT_DIR,"battle_spot_mons.h")

# Trainer Details
OUTPUT_TRAINERS = os.path.join(OUTPUT_DIR,"battle_spot_trainers.h")

# Pre-Constructed trainer mons (per user)
OUTPUT_TRAINER_MONS = os.path.join(OUTPUT_DIR,"battle_spot_trainer_mons.h")

ORDERED_FIELDS = ["hp", "atk", "def", "spe", "spa", "spd"]

def get_set_hash(set: object):
    return hash(json.dumps(set))

def get_mon_data(mon_const: str, set: object): 

    # General / other fields
    other = set["other"]

    # Mon data array
    mon_data = [
        f"[{mon_const}] = " + "{"
    ]

    # Species
    mon_data.append(
        f"    .species = {common.get_species_constant(set['species'])},"
    )

    # Moves (Open)
    mon_data.append(
        "    .moves = {"
    )

    for move in set['moves']:
        mon_data.append(
            f"        MOVE_{common.get_constant(move)},"
        )

    # Moves (Close)
    mon_data.append(
        "    },"
    )

    # Held Item
    if "item" in set:
        mon_data.append(
            f"    .heldItem = ITEM_{common.get_constant(set['item'])},"
        )

    # IVs
    if "ivs" in set:
        ivs = []

        for field in ORDERED_FIELDS:
            stat = 31
            if field in set["ivs"]:
                stat = str(set["ivs"][field])

            ivs.append(stat)

        mon_data.append(
            "    .iv = TRAINER_PARTY_IVS(" + 
            ", ".join(ivs) + 
            "),"
        )

    # EVs (Open)
    if "evs" in set:
        evs = []

        for field in ORDERED_FIELDS:
            stat = 0
            if field in set["evs"]:
                stat = str(set["evs"][field])

            evs.append(stat)

        mon_data.append(
            "    .ev = TRAINER_PARTY_EVS(" + 
            ", ".join(evs) + 
            "),"
        )

    # Ball
    if "ball" in other:
        mon_data.append(
            f"    .ball = ITEM_{common.get_constant(other['ball'])},"
        )

    # Friendship
    friendship = 255
    if "friendship" in other:
        friendship = other["friendship"]
    elif "Frustration" in set["moves"]:
        friendship = 0 # Max. Frustration Power
    
    mon_data.append(
        f"    .friendship = {friendship},"
    )

    # Nature
    if "nature" in set:
        mon_data.append(
            f"    .nature = NATURE_{common.get_constant(set['nature'])},"
        )

    # Gender
    gender = None
    if "gender" in set:
        if set["gender"].lower() == "f": 
            gender = "GENDER_FEMALE"
        elif set["gender"].lower() == "m":
            gender = "GENDER_MALE"
    
    if gender:
        mon_data.append(
            f"    .gender = {gender},"
        )

    # Shininess
    if "shiny" in other:
        mon_data.append(
            f"    .isShiny = {other['shiny']},"
        )
        
    # Dynamax Level
    dynamaxLevel = 10
    if "dynamax level" in other:
        dynamaxLevel = other['dynamax level']
    mon_data.append(
        f"    .dynamaxLevel = {dynamaxLevel},"
    )

    # Gigantamax Factor
    if "gigantamax" in other:
        mon_data.append(
            f"    .gigantamaxFactor = {other['gigantamax']},"
        )

    # Should Dynamax (AI)
    if "should dynamax" in other:
        mon_data.append(
            f"    .shouldDynamax = {other['should dynamax']},"
        )

    # Should Tera (AI)
    if "should terastal" in other:
        mon_data.append(
            f"    .shouldTerastal = {other['should terastal']},"
        )

    # Close data structure
    mon_data.append(
        "},"
    )

    # Return mon data
    return mon_data

if __name__ == '__main__':

    output_mons = [
        "// File Auto-Generated By tools/bfg_helpers/battle_spot.py",
        "",
    ]
    output_trainers = [
        "// File Auto-Generated By tools/bfg_helpers/battle_spot.py",
        "",
    ]
    output_trainer_mons = [
        "// File Auto-Generated By tools/bfg_helpers/battle_spot.py",
        "",
    ]

    # Prevent duplicate sets
    set_hashes = {

    }

    mon_data = {}
    mon_const_data = {}

    trainer_data = {}
    trainer_const_data = {}

    common_data = {}

    # Constant Values
    trainer_ids = {}
    mon_ids = {}

    # For duplicate constants
    duplicate_trainers = {}
    duplicate_species = {}

    # Get list of input files
    files = os.listdir(INPUT_FOLDER)

    # Loop over the files
    for file_name in files:

        # File Name Format
        # [folder]_[subfolder]_[name]_[tier]_[rating].[team] OR
        # [folder]_[subfolder].[set]

        # Split filename, extension from file info
        no_extension, extension = file_name.split(".")

        # Combine the file path for the input file
        file_path = os.path.join(INPUT_FOLDER, file_name)

        # Open the file contents
        with open(file_path, "r") as file:

            # File headers (e.g. trainer class, etc.)
            # Headers follow the syntax .[key] = [value]
            trainer_headers = {}

            raw_lines = []
            lines = file.readlines()

            # Check for headers
            for line in lines:
                if line.startswith('.'):
                    key, value = line[1:].split("=")

                    # Strip whitespace
                    key = key.strip()
                    value = value.strip()

                    # Add k,v to headers
                    trainer_headers[key] = value
                else:
                    # Add the raw line with whitespace stripped
                    raw_lines.append(line.strip())

            # Read the raw file
            raw = "\n".join(raw_lines)

            # Parse the showdown data
            sets = parser.parse_sets(raw)

            mon_count = len(sets)

            # Treat as entire team
            if extension == "team":
                    
                # Split the names on the under score
                battle_type, battle_format, player_name = no_extension.split("_")[:3]

                # Generate Trainer Constant
                trainer_const = f"BATTLE_SPOT_TRAINER_{battle_type}_{battle_format}_{player_name}".upper()
                
                # Trainer Mon Global Array Name
                trainer_mon_array = f"gBattleSpotTrainerMons{battle_type.capitalize()}{battle_format.capitalize()}{player_name.capitalize()}"

                if trainer_const in duplicate_trainers:
                    duplicate_trainers[trainer_const] += 1
                    trainer_mon_array = f"{trainer_mon_array}_{duplicate_trainers[trainer_const]}"
                    trainer_const = f"{trainer_const}_{duplicate_trainers[trainer_const]}"
                else: # Not duplicate
                    duplicate_trainers[trainer_const] = 1

                # Add array open to trainer mons file
                output_trainer_mons += [
                    f"// {battle_type}/{battle_format} - {player_name}",
                    f"const u16 {trainer_mon_array}[] = " + "{"
                ]

                # Generate Mon Data
                if battle_type not in mon_data:
                    mon_data[battle_type] = {}
                if battle_type not in mon_const_data:
                    mon_const_data[battle_type] = {}

                if battle_format not in mon_data[battle_type]:
                    mon_data[battle_type][battle_format] = []
                if battle_format not in mon_const_data[battle_type]:
                    mon_const_data[battle_type][battle_format] = []

                if battle_type not in mon_ids:
                    mon_ids[battle_type] = {}
                if battle_format not in mon_ids[battle_type]:
                    mon_ids[battle_type][battle_format] = 0

                # Loop over sets (Limit: 4)
                for set in sets[:4]:

                    # Get the hash for the set
                    set_hash = get_set_hash(set)

                    # Set already hashed
                    if set_hash in set_hashes:

                        # Get the const from the hash set
                        mon_const = set_hashes[set_hash]

                        # Add mon constant to the trainer mon list
                        output_trainer_mons.append(
                            f"    {mon_const},"
                        )

                    else: # Not already hashed

                        # Generate Constants
                        mon_const = f"BATTLE_SPOT_MON_{battle_type}_{battle_format}_{common.get_constant(set['species'])}".upper()
                        if mon_const in duplicate_species:
                            duplicate_species[mon_const] += 1
                            mon_const = f"{mon_const}_{duplicate_species[mon_const]}"
                        else: # Not duplicate
                            duplicate_species[mon_const] = 1

                        # Add the mon constant to the list
                        mon_const_data[battle_type][battle_format].append(
                            f"#define {mon_const} {mon_ids[battle_type][battle_format]}"
                        )

                        # Add mon constant to the trainer mon list
                        output_trainer_mons.append(
                            f"    {mon_const},"
                        )

                        # Add the mon data to the constant
                        mon_data[battle_type][battle_format] += get_mon_data(mon_const, set)

                        # Add the hash, const to the list
                        set_hashes[set_hash] = mon_const

                        # Increment the mon id for the type, format
                        mon_ids[battle_type][battle_format] += 1

                # Add closing bracket, newline to mons list
                output_trainer_mons.append(f"    -1,")
                output_trainer_mons.append("};")
                output_trainer_mons.append("")

                # Generate Trainer Data

                # Create trainer data pathways
                if battle_type not in trainer_data:
                    trainer_data[battle_type] = {}
                if battle_format not in trainer_data[battle_type]:
                    trainer_data[battle_type][battle_format] = []

                # Create trainer const data pathways
                if battle_type not in trainer_const_data:
                    trainer_const_data[battle_type] = {}
                if battle_format not in trainer_const_data[battle_type]:
                    trainer_const_data[battle_type][battle_format] = []

                # Create trainer id defaults
                if battle_type not in trainer_ids:
                    trainer_ids[battle_type] = {}
                if battle_format not in trainer_ids[battle_type]:
                    trainer_ids[battle_type][battle_format] = 0

                # Add the trainer constant to the list
                trainer_const_data[battle_type][battle_format].append(
                    f"#define {trainer_const} {trainer_ids[battle_type][battle_format]}"
                )

                trainer_data[battle_type][battle_format].append(
                    f"[{trainer_const}] = " + "{",
                )

                trainer_data[battle_type][battle_format].append("    .trainer = {")
                
                # Loop over the trainer headers
                for header in trainer_headers:
                    if header not in battle_spot_headers:
                        trainer_data[battle_type][battle_format].append(f"        .{header} = {trainer_headers[header]},")

                # Add mon set reference
                trainer_data[battle_type][battle_format].append(
                    f"        .monSet = {trainer_mon_array},"
                )

                trainer_data[battle_type][battle_format].append("    },")

                for header in battle_spot_headers:
                        trainer_data[battle_type][battle_format].append(f"    .{header} = {trainer_headers[header]},")

                trainer_data[battle_type][battle_format].append(
                    "},"
                )

                # Increment the trainer id for the type, format
                trainer_ids[battle_type][battle_format] += 1

            # Treat as sample sets
            elif extension == "sets":
                    
                # Split the names on the under score
                battle_type, battle_format = no_extension.split("_")[:2]

                # Common Data
                if battle_type not in common_data:
                    common_data[battle_type] = {}
                if battle_format not in common_data[battle_type]:
                    common_data[battle_type][battle_format] = []

                # Generate Mon Data
                if battle_type not in mon_data:
                    mon_data[battle_type] = {}
                if battle_type not in mon_const_data:
                    mon_const_data[battle_type] = {}

                if battle_format not in mon_data[battle_type]:
                    mon_data[battle_type][battle_format] = []
                if battle_format not in mon_const_data[battle_type]:
                    mon_const_data[battle_type][battle_format] = []

                if battle_type not in mon_ids:
                    mon_ids[battle_type] = {}
                if battle_format not in mon_ids[battle_type]:
                    mon_ids[battle_type][battle_format] = 0

                # Loop over the sets
                for set in sets:

                    # Get the hash for the set
                    set_hash = get_set_hash(set)

                    # Set already hashed
                    if set_hash in set_hashes:

                        # Get the const from the hash set
                        mon_const = set_hashes[set_hash]

                        # Add the mon const to the common Pokemon (if not present)
                        if mon_const not in common_data[battle_type][battle_format]:
                            common_data[battle_type][battle_format].append(mon_const)

                    else: # Not already hashed

                        # Generate Constants
                        mon_const = f"BATTLE_SPOT_MON_{battle_type}_{battle_format}_{common.get_constant(set['species'])}".upper()
                        if mon_const in duplicate_species:
                            duplicate_species[mon_const] += 1
                            mon_const = f"{mon_const}_{duplicate_species[mon_const]}"
                        else: # Not duplicate
                            duplicate_species[mon_const] = 1

                        # Add the mon constant to the list
                        mon_const_data[battle_type][battle_format].append(
                            f"#define {mon_const} {mon_ids[battle_type][battle_format]}"
                        )

                        # Add the mon const to the common Pokemon list
                        common_data[battle_type][battle_format].append(mon_const)

                        # Add the mon data to the constant
                        mon_data[battle_type][battle_format] += get_mon_data(mon_const, set)

                        # Add the hash, const to the list
                        set_hashes[set_hash] = mon_const

                        # Increment the mon id for the type, format
                        mon_ids[battle_type][battle_format] += 1

            else:  # Unhandled extension
                raise Exception(
                    f"Unhandled file extension {extension}! Accepted: .sets, .team ..."
                )

    # Build Mons Data Set Output
    for battle_type in mon_const_data:
        for battle_format in mon_const_data[battle_type]:
            
            # Pokemon
            output_mons.append(f"// {battle_type} - {battle_format}")
            mon_count_const = f"BATTLE_SPOT_MON_{battle_type.upper()}_{battle_format.upper()}_COUNT"

            output_mons.append(
                f"#define {mon_count_const} {mon_ids[battle_type][battle_format]}"
            )

            # Add empty line
            output_mons.append("")

            # Loop over the constants
            for const in mon_const_data[battle_type][battle_format]:
                output_mons.append(const)

            # Add empty line
            output_mons.append("")

            # Create the data structure
            output_mons.append(
                f"const struct TrainerMon gBattleSpotMons{battle_type.capitalize()}{battle_format.capitalize()}[{mon_count_const}] = " + "{"
            )

            # Loop over all of the mons
            for line in mon_data[battle_type][battle_format]:
                output_mons.append(f"    {line}")

            output_mons.append("};")
            
    # Build Common Mons Data Set Output
    for battle_type in common_data:
        for battle_format in common_data[battle_type]:

            common_const = f"gBattleSpotTrainerMons{battle_type.capitalize()}{battle_format.capitalize()}Common"

            output_trainer_mons.append(f"// {battle_type}/{battle_format} - common")
            output_trainer_mons.append(f"const u16 {common_const}[] = " + "{")

            for mon in common_data[battle_type][battle_format]:
                output_trainer_mons.append(f"    {mon},")

            output_trainer_mons.append(f"    -1,")

            output_trainer_mons.append("};")
            output_trainer_mons.append("")

    # Build Trainers Data Set Output
    for battle_type in trainer_const_data:
        for battle_format in trainer_const_data[battle_type]:

            # Trainers
            output_trainers.append(f"// {battle_type} - {battle_format}")
            trainer_count_const = f"BATTLE_SPOT_TRAINER_{battle_type.upper()}_{battle_format.upper()}_COUNT"

            output_trainers.append(
                f"#define {trainer_count_const} {trainer_ids[battle_type][battle_format]}"
            )
            
            # Add empty line
            output_trainers.append("")

            # Loop over the constants
            for const in trainer_const_data[battle_type][battle_format]:
                output_trainers.append(const)

            # Add empty line
            output_trainers.append("")

            # Create the data structure
            output_trainers.append(
                f"const struct BattleSpotTrainer gBattleSpotTrainers{battle_type.capitalize()}{battle_format.capitalize()}[{trainer_count_const}] = " + "{"
            )

            # Loop over all of the trainers
            for line in trainer_data[battle_type][battle_format]:
                output_trainers.append(f"    {line}")

            output_trainers.append("};")

    # Dump the mon data to the file
    with open(OUTPUT_MONS, "w+") as file:
        file.write("\n".join(output_mons))

    # Dump the trainer data to the file
    with open(OUTPUT_TRAINERS, "w+") as file:
        file.write("\n".join(output_trainers))

    # Dump the trainer mon data to the file
    with open(OUTPUT_TRAINER_MONS, "w+") as file:
        file.write("\n".join(output_trainer_mons))
